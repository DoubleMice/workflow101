# 作业 2：Test Workflow

> 构建一个自动化测试生成工具，为 C/C++ 项目生成测试套件并驱动质量闭环。

**核心模式**：Explore → Fan-out/Fan-in → Test-Driven → Event-Driven

**术语**

- Coverage（覆盖率，测试执行到的代码占总代码的比例）
- gcov（GCC 自带的代码覆盖率工具）
- Boundary Test（边界测试，针对输入边界值的测试用例）
- Fuzz Testing（模糊测试，用随机/半随机数据探测程序崩溃）
- Regression Suite（回归测试套件，防止旧功能被新改动破坏）

### 背景

你的 C/C++ 网络库有 12000 行代码，但测试覆盖率只有 23%。老板说："下个迭代之前，核心模块的覆盖率要到 80%。"

手动写测试太慢，而且容易漏掉边界情况。你决定用 Claude Code 的 workflow 编排，构建一个自动化测试生成工具——它能读懂代码，自动生成测试，跑测试，发现失败后自动修复，直到全部通过。

### 需求描述

**输入**: 一个本地 C/C++ 项目的路径，可选指定模块

**输出**:
- 生成的测试文件（每个源文件对应一个测试文件）
- 测试执行报告（通过/失败/跳过）
- 覆盖率报告（行覆盖率、分支覆盖率）

### 你需要自己决定的事

教程中的 Review Bot 把审查拆成 4 个固定维度并行跑，因为审查维度之间几乎没有依赖。但测试生成不一定适合同样的拆法。

**Q1: 按什么维度拆分测试生成 agent？**

至少有三种拆法：

- **按测试类型拆**（正常路径 / 边界条件 / 错误处理 / 并发安全 / ...）：每个 agent 专注一种测试策略，容易并行。但同一个函数会被多个 agent 重复分析，且 agent 之间可能生成重复的测试用例。
- **按模块拆**（parser / conn_pool / http_handler / ...）：每个 agent 负责一个模块的完整测试，上下文更集中。但不同模块的复杂度差异大，agent 负载不均衡。
- **按覆盖率缺口拆**：先跑一轮基础测试拿到覆盖率数据，再按未覆盖的代码路径分配给不同 agent 定向补充。精准度最高，但变成了两阶段串行。

你选哪种？还是混合使用？

**Q2: 多个 agent 的测试怎么合并？**

如果多个 agent 并行生成测试，合并时会遇到实际问题：
- 重复的测试用例怎么去重？
- 冲突的 mock 或全局状态设置怎么处理？
- 测试文件的组织结构怎么定——按维度分文件，还是按模块分文件？

**Q3: 修复循环的策略是什么？**

"最多 3 轮"是最简单的策略。但你可以设计更聪明的方案：
- 编译失败和运行失败是否应该用不同的修复策略？
- 如果第 2 轮修复引入了新的失败，是继续修还是回退？
- 覆盖率未达标算"失败"吗？要不要触发额外的测试生成？

**技术要求**

1. 用 CLI 封装（typer），支持 `testgen run <project-path>` 命令
2. 可选 `--module <name>` 参数，只为指定模块生成测试
3. agent 的数量和分工由你自己设计——不一定按测试类型拆，不一定全部并行
4. 生成前先用 Explore agent 理解项目结构和已有测试
5. 生成的测试必须能通过 `gcc -Wall -Werror` 编译
6. 自动运行测试，失败则分析原因并修复（修复策略由你设计）
7. 最终用 gcov 生成覆盖率报告，输出行覆盖率和分支覆盖率
8. 支持 `--coverage-target 80` 参数设定目标覆盖率，未达标时给出建议

### 提示：你会用到哪些模式？

- [ ] **Explore** — 理解项目结构、已有测试、依赖关系
- [ ] **Specialized Agent** — 按你选择的维度拆分测试生成专家
- [ ] **Fan-out / Fan-in** — 并行生成测试（如果你的设计允许并行）
- [ ] **Test-Driven** — 编译 → 运行 → 失败修复循环
- [ ] **Event-Driven** — 可选：Hook 在代码变更后自动重新生成测试

### 参考架构

下面是一种可能的架构（按测试类型拆分）。你完全可以按模块拆、按覆盖率缺口拆、或者混合使用。

```
testgen run <path> [--module parser] [--coverage-target 80]
    │
    ├── 1. Explore: 理解项目结构
    │   └── 输出: 源文件列表、已有测试、公开接口、依赖关系
    │
    ├── 2. 你的 agent 编排（设计由你决定）
    │   ├── 几个 agent？按什么维度拆？
    │   ├── 并行还是串行？
    │   └── 生成的测试文件怎么组织？
    │
    ├── 3. 合并: 统一测试套件
    │   └── 去重、解决冲突、生成 Makefile/CMake 规则
    │
    ├── 4. Test-Driven: 编译运行循环
    │   ├── gcc -Wall -Werror 编译
    │   ├── 运行测试
    │   └── 失败 → 你的修复策略 → 重新编译运行
    │
    └── 5. Coverage: 覆盖率报告
        ├── gcov 生成覆盖率数据
        ├── 对比目标覆盖率
        └── 未达标 → 建议补充测试的函数列表
```

### 验收标准

1. `testgen run ./my-network-lib` 一条命令生成完整测试套件
2. 报告覆盖了你设计的所有测试维度，且能说清拆分理由
3. 生成的测试文件能通过编译且运行结果有通过/失败/跳过的统计
4. 覆盖率报告包含行覆盖率和分支覆盖率
5. 单个 agent 生成失败不影响其他测试的生成

### 进阶挑战

- 支持增量测试生成：只为 git diff 中变更的函数生成新测试
- 集成 ASan（AddressSanitizer）：编译时加 `-fsanitize=address`，捕获运行时内存错误
- 支持 Fuzz Testing：为关键解析函数生成 libFuzzer harness
- 用 Hook 实现"每次修改 .c 文件后自动重跑相关测试"

---

